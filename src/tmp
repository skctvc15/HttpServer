    addsig( SIGPIPE,SIG_IGN );                              //忽略sigpipe信号

    if (initSocket() < 0)
    {
        fprintf(stderr,"initSocket failed \n");
        return -1;
    }


    threadpool<HTTPServer>* pool = new threadpool<HTTPServer>();
    while (1) {
        int epfd = epoll_create(5);
        if (epfd == -1) {
            perror("epoll_create");
            exit(EXIT_FAILURE);
        }
        addfd(epfd, listenfd, false);       //listenfd cannot be oneshot
        HTTPServer::m_epollfd = epfd;

        //we use ET model here
        while(1) {
            int ready = epoll_wait(epfd,evlist,MAX_EVENTS,-1);
            if (ready < 0) {
                fprintf(stderr,"epoll failure\n");
                break;
            }

            for (int i = 0;i < ready;i++) {
                int sockfd = evlist[i].data.fd;
                if (sockfd == listenfd) {
                    clilen = sizeof(cliaddr);
                    int connfd = accept(listenfd,reinterpret_cast<struct sockaddr *>(&cliaddr),&clilen);
                    if (connfd < 0)
                    {
                        perror("Accept");
                        continue;
                    }
                    init_epfd(connfd);
                } else if (evlist[i].events & EPOLLIN) {
                    printf(" event trigger \n");
                    //pthread_t thread;
                    m_sockfd = sockfd;
                    //pthread_create(&thread,NULL,worker,this);
                    pool->append(this);
                } else if(evlist[i].events & (EPOLLHUP | EPOLLERR)) {
                    printf("closing fd %d\n",evlist[i].data.fd);
                    if (close(evlist[i].data.fd) == -1) {
                        perror("close");
                        exit(EXIT_FAILURE);
                    }
                } else {
                    fprintf(stderr," something else happened\n");
                }
            }
        }
    }

    close(listenfd);
    return 0;
}
